#  File R/ergm_mplecov.R in package ergm, part of the Statnet suite
#  of packages for network analysis, https://statnet.org .
#
#  This software is distributed under the GPL-3 license.  It is free,
#  open source, and has the attribution requirements (GPL Section 7) at
#  https://statnet.org/attribution
#
#  Copyright 2003-2020 Statnet Commons
#######################################################################
#' Approximate MPLE standard errors in dyad-dependent models
#' 
#' Function to approximate the MPLE covariance matrix in a dyad dependence model 
#' using the Godambe matrix as described in Schmid and Hunter (2020) or by parametric bootstrap
#' as described by Schmid and Desmarais (2017).
#' 
#' @param pl An \code{\link{ergm.pl}} object.
#' @param nw response network.
#' @param fd An \code{\link{rlebdm}} with informative dyads.
#' @param m the model, as returned by \code{\link{ergm_model}}
#' @param theta.mple the MPLE of a given model
#' @param invHess the inverse Hessian matrix obtained from glm()
#' @param control a list of MCMC related parameters; recognized
#'   components include: samplesize : the number of networks to sample
#'   Clist.miss : see 'Clist.miss' above; some of the code uses this
#'   Clist.miss,
#' @param verbose whether this and the C routines should be verbose (T
#'   or F); default=FALSE
#' @return \code{ergm_mplecov} returns a list either
#'   containing a Godambe covariance matrix or a diagonal matrix with bootstrap variances.
#' 
#' @references Schmid CS and Desmarais BA (2017). "Exponential random graph 
#' models with big networks: Maximum pseudolikelihood estimation and the parametric bootstrap" 
#' _IEEE International Conference on Big Data (Big Data)_, pp. 116-121.
#' 
#' Schmid CS and Hunter DR (2020).  "Accounting for Model Misspecification When Using 
#' Pseudolikelihood for ERGMs" _Working Paper_.


ergm_mplecov <- function(pl,nw, fd, m,  theta.mple, invHess,  control,
                         verbose){
  
  # get sample size from control.ergm
  R <- control$MPLE.covariance.samplesize
  
  # Simulate R networks
  sim.mple <- simulate(m, nsim=R, coef=theta.mple, basis=nw, control=control.simulate.formula(MCMC.burnin=5000, MCMC.interval=3000))
  
  X <- pl$xmat
  num.variables <- ncol(pl$xmat)
  
  if(control$MPLE.covariance.method == "Godambe"){
    message("Estimating Godambe Matrix using ", R, " simulated networks.")
    
    # calculation of V(theta) = Var(u(theta,y)) using the sim.num networks
    net.stat <- matrix(0, nrow=length(sim.mple), ncol=num.variables)
    colnames(net.stat) <- colnames(pl$xmat)
    u.data <- matrix(0,nrow=length(sim.mple), ncol=num.variables)
    
    for(i in 1:length(sim.mple)){
      # replace response network in formula and get MPLE of simulated network
      pl_sim <- ergm.pl(nw=sim.mple[[i]], fd=fd, m=m, theta.offset=init, 
                        control=control,verbose=verbose)
      # write the response, weight and designmatrix into one matrix
      X.dat <- cbind(pl_sim$zy, pl_sim$wend, pl_sim$xmat)
      # calculate s(theta)
      u.data[i,] <- sapply(1:num.variables, function(k){
        sum(apply(X.dat, 1, function(x){
          x[2]*(x[k+2]*(x[1] - exp(sum(theta.mple*x[(3:(num.variables+2))]))/(1+exp(sum(theta.mple*x[(3:(num.variables+2))]))) )) } ) ) } )
    } # end for i
    # calculate V.hat by estimating sd
    u.mean <- colMeans(u.data)
    u.sum <- matrix(0,num.variables,num.variables)
    for(i in 1: nrow(u.data)){
      u.diff <- u.data[i,]- u.mean
      u.sum <- u.sum + u.diff%*%t(u.diff)
    }
    u.sum.n <- u.sum/(nrow(u.data)-1)
    G <- invHess%*%u.sum.n%*%invHess
    return(G)
  } # end if Godambe
  if(control$MPLE.covariance.method == "bootstrap"){ 
    message("Estimating Bootstrap Standard Errors using ", R, " simulated networks.")
    # create empty matrix to store mple of bootstrap samples
    boot.mple.mat <- matrix(0, nrow=length(sim.mple), ncol=num.variables)
    colnames(boot.mple.mat) <- colnames(pl$xmat)
    
    for(i in 1:length(sim.mple)){
      # replace response network in formula
      pl_sim <- ergm.pl(nw=sim.mple[[i]], fd=fd, m=m, theta.offset=init,control=control,
                        verbose=verbose)
      # calculate MPLE of simulated network
      glm.sim <- glm(pl_sim$zy ~ .-1 + offset(pl_sim$foffset), data=data.frame(pl_sim$xmat),
                     weights=pl_sim$wend, family="binomial")
      boot.mple.mat[i,] <- coef(glm.sim)
    }# end for i
    Boot.cov <- matrix(0,num.variables, num.variables)
    diag(Boot.cov) <- apply(boot.mple.mat, 2, var)
    return(Boot.cov)
  } # end if bootstrap
} # end function
