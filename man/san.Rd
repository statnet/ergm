% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ergm.san.R
\name{san}
\alias{san}
\alias{san.default}
\alias{san.formula}
\alias{san.ergm}
\title{Use Simulated Annealing to attempt to match a network to a vector of mean
statistics}
\usage{
san(object, ...)

\method{san}{formula}(object, response = NULL, reference = ~Bernoulli,
  constraints = ~., target.stats = NULL, nsim = 1, basis = NULL,
  output = c("network", "edgelist", "pending_update_network"),
  only.last = TRUE, control = control.san(), verbose = FALSE, ...)

\method{san}{ergm}(object, formula = object$formula,
  constraints = object$constraints, target.stats = object$target.stats,
  nsim = 1, basis = NULL, output = c("network", "edgelist",
  "pending_update_network"), only.last = TRUE,
  control = object$control$SAN.control, verbose = FALSE, ...)
}
\arguments{
\item{object}{Either a \code{\link{formula}} or an \code{\link{ergm}} object. The
\code{\link{formula}} should be of the form \code{y ~ <model terms>}, where
\code{y} is a network object or a matrix that can be coerced to a
\code{\link{network}} object.  For the details on the
possible \code{<model terms>}, see \code{\link{ergm-terms}}.  To
create a \code{\link[network]{network}} object in , use the
\code{network()} function, then add nodal attributes to it using
the \code{\%v\%} operator if necessary.}

\item{\dots}{Further arguments passed to other functions.}

\item{response}{Name of the edge attribute whose value
is to be modeled. Defaults to \code{NULL} for simple presence or absence.}

\item{reference}{One-sided formula whose RHS gives the
reference measure to be used. (Defaults to \code{~Bernoulli}.)}

\item{constraints}{A one-sided formula specifying one or more constraints on
the support of the distribution of the networks being simulated. See the
documentation for a similar argument for \code{\link{ergm}} and see
\link[=ergm-constraints]{list of implemented constraints} for more information. For
\code{simulate.formula}, defaults to no constraints. For
\code{simulate.ergm}, defaults to using the same constraints as those with
which \code{object} was fitted.}

\item{target.stats}{A vector of the same length as the number of terms
implied by the formula, which is either \code{object} itself in the case of
\code{san.formula} or \code{object$formula} in the case of \code{san.ergm}.}

\item{nsim}{Number of desired networks.}

\item{basis}{If not NULL, a \code{network} object used to start the Markov
chain.  If NULL, this is taken to be the network named in the formula.}

\item{output}{Character, one of \code{"network"} (default),
\code{"edgelist"}, or \code{"pending_update_network"}: determines the
output format. Partial matching is performed.}

\item{only.last}{if \code{TRUE}, only return the last network generated;
otherwise, return a \code{\link{network.list}} with \code{nsim} networks.}

\item{control}{A list of control parameters for algorithm tuning; see
\code{\link{control.san}}.}

\item{verbose}{Logical or numeric giving the level of verbosity. Higher values produce more verbose output.}

\item{formula}{(By default, the \code{formula} is taken from the \code{ergm}
object.  If a different \code{formula} object is wanted, specify it here.}
}
\value{
A network or list of networks that hopefully have network
statistics close to the \code{target.stats} vector.
}
\description{
This function attempts to find a network or networks whose statistics match
those passed in via the \code{target.stats} vector.
}
\section{Methods (by class)}{
\itemize{
\item \code{formula}: Sufficient statistics are specified by a \code{\link{formula}}.

\item \code{ergm}: Sufficient statistics and other settings are
inherited from the \code{\link{ergm}} fit unless overridden.
}}

\examples{
# initialize x to a random undirected network with 100 nodes and a density of 0.1
x <- network(100, density = 0.1, directed = F)
 
# try to find a network on 100 nodes with 600 edges, 300 triangles, and 2500 4-cycles, starting from the network x
y <- san(x ~ edges + triangles + cycle(4), target.stats = c(600, 300, 2500))

summary(y ~ edges + triangles + cycle(4))
   edges triangle   cycle4 
     596      301     2502 
# close, but we didn't quite get there after one iteration

# try chaining 5 iterations together, returning 5 networks as a network.list
z <- san(x ~ edges + triangles + cycle(4), target.stats = c(600, 300, 2500), nsim = 5, only.last=F)

summary(z ~ edges + triangles + cycle(4))
     edges triangle cycle4
[1,]   597      301   2501
[2,]   597      299   2500
[3,]   599      299   2498
[4,]   600      300   2500
[5,]   600      300   2500
# got there after 4 iterations


# initialize x to a random directed network with 100 nodes
x <- network(100)

# add vertex attributes
x \%v\% 'give' <- runif(100, 0, 1)
x \%v\% 'take' <- runif(100, 0, 1)

# try to find a set of 200 directed edges making the outward sum of 'give' and the inward sum of 'take' both equal to 125,
# so in edges (i,j) the node i tends to have above average 'give' and j tends to have above average 'take'
y <- san(x ~ edges + nodeocov('give') + nodeicov('take'), target.stats = c(200, 125, 125))

summary(y ~ edges + nodeocov('give') + nodeicov('take'))
        edges nodeocov.give nodeicov.take 
      200.000       124.183       124.529 
# pretty close; we can't expect perfection on this one


# initialize x to a random undirected network with 100 nodes
x <- network(100, directed = F)

# add a vertex attribute
x \%v\% 'popularity' <- runif(100, 0, 1)

# try to find a set of 200 edges making the total sum of popularity(i) and popularity(j) over all edges (i,j) equal to 250,
# so nodes with higher popularity are more likely to be connected to other nodes
y <- san(x ~ edges + nodecov('popularity'), target.stats = c(200, 250))
 
summary(y ~ edges + nodecov('popularity'))
             edges nodecov.popularity 
          200.0000           249.4979 

# creates a network with denser "core" spreading out to sparser "periphery"
plot(y)
}
\keyword{models}
